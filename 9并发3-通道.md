### 一：通道概述
1. goroutine是go语言程序的并发体，channel是它们之间的通信机制
2. 一个channel是一个通信机制，可以让一个goroutine通过它给另一个goroutine发送值信息。
3. 每个channel都有一个特殊的类型，就是channel可发送的数据类型。发送int的channel 写为chan int
4. go语言建议使用通信的方法代替共享内存。
5. 通信：当一个资源需要再goroutine之间共享时，通道在goroutine之间架起了一个管道，并提供了确保同步交换数据的机制
6. 声明通道时，需要指定将要被共享的数据的类型。

### 二：通道特性
1. 在任何时候，同时只能有一个goroutine访问通道进行发送和获取数据
2. 通道像一个传说带或者队列，遵循先进先出的规则，保证收发数据的顺序

### 三：通道使用
1. 声明通道类型
```
var 通道变量 chan 通道类型
#通道类型：通道内的数据类型
#通道变量：保存通道的变量
#chan类型的空值是nil
```
2. 创建通道
```
通道实例 := make(chan 数据类型)
#通道时引用类型，需要使用make进行创建
#数据类型：通道内传输的元素类型
#通道实例：通过make创建的通道句柄
```
3. 使用通道发送数据
4. 使用通道接收数据

### 四：使用通道发送数据
1. 通道创建后，就可以使用通道进行发送和接收操作
2. 通道的发送使用特殊的操作符<-
```
通道变量 <- 值
#通道变量：通过make创建好的通道实例
#值：可以是变量、常量、表达式或者函数返回值等。值类型必须与ch通道的元素类型一致
```
3. 把数据往通道中发送时，如果接收方一直都没有接受，那么发送操作将持续阻塞。

### 五：通道接收数据特性
1. 通道的收发操作在不同的两个goroutine间进行

`由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个goroutine中进行`
2. 接收将持续阻塞知道发送方发送数据

`如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止`
3. 每次接收一个元素

`通道一次只能接收一个数据元素`

### 六：通道接收数据的4种写法
1. 阻塞接收数据
```
data :=  <-ch

#执行该语句时将会阻塞，直到接收到数据并赋值给data变量
```
2. 非阻塞接收数据
```
data, ok := <-ch

#使用非阻塞方式从通道接收数据时，语句不会发生阻塞
#data：表示接收到的数据，未接收到数据时，data未通道类型的零值
#ok：表示是否接收到数据

#非阻塞的通道接收方法可能造成高的CPU占用，因此使用非常少。如果需要实现接收超时检测，可以配合select和计时器channel进行
```
3. 接收任意数据，忽略接收的数据
```
<-ch

#阻塞接收数据后，忽略从通道返回的数据
#执行该语句时将会发生阻塞，直到接收数据，但接收到的数据会被忽略。
#这个方式实际上只是通过通道在goroutine间阻塞收发实现并发同步
```
4. 循环接收
```
通道的数据接收可以借用for语句进行多个元素的接收操作
使用for range遍历管道
```
